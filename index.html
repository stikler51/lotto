<!DOCTYPE html>

<html>

<head>
  <title>Rigid body - Physijs</title>
  
  <link rel="stylesheet" type="text/css" href="js/physijs/examples/css/styles.css"/>
  
  <script type="text/javascript" src="js/physijs/examples/js/three.min.js"></script>
  <script type="text/javascript" src="js/physijs/physi.js"></script>
  <script src="js/OrbitControls.js"></script>
  <!--<script src="js/three-csg.js"></script>-->
  <script src="./js/physijs/examples/js/three.min"></script>
  
  <script type="text/javascript">

      'use strict';

      // import * as THREE from "./js/physijs/examples/js/three.min";

      Physijs.scripts.worker = 'js/physijs/physijs_worker.js';
      Physijs.scripts.ammo = 'examples/js/ammo.js';

      var initScene, render, loader, renderer, scene, ground, light, camera;
      
      let winningBalls = [];

      initScene = function () {
          renderer = new THREE.WebGLRenderer({antialias: true});
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setClearColor('skyblue');
          renderer.shadowMap.enabled = true;
          renderer.shadowMapSoft = true;
          document.getElementById('viewport').appendChild(renderer.domElement);

          scene = new Physijs.Scene;
          scene.setGravity(new THREE.Vector3(0, -400, 0));
          scene.addEventListener(
              'update',
              function () {
                  scene.simulate(undefined, 1);
              }
          );

          camera = new THREE.PerspectiveCamera(
              35,
              window.innerWidth / window.innerHeight,
              1,
              1000
          );
          camera.position.set(0, 20, 450);
          camera.lookAt({x: 0, y: 20, Z: 0});
          scene.add(camera);

          // var controls = new THREE.OrbitControls(camera, renderer.domElement);

          // Light
          var ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.9); // soft white light (мягкий белый свет)
          scene.add(ambientLight);

          light = new THREE.DirectionalLight(0xFFFFFF);
          light.position.set(20, 40, -15);
          light.target.position.copy(scene.position);
          light.castShadow = true;
          light.shadowCameraLeft = -60;
          light.shadowCameraTop = -60;
          light.shadowCameraRight = 60;
          light.shadowCameraBottom = 60;
          light.shadowCameraNear = 20;
          light.shadowCameraFar = 200;
          light.shadowBias = -.0001;
          light.shadowMapWidth = light.shadowMapHeight = 2048;
          light.shadowDarkness = .7;
          scene.add(light);

          // Loader
          loader = new THREE.TextureLoader();
          
          // var balls = [makeBall(14, 0, 0), makeBall(0, 15, 0), makeBall(-14, 0, 0), makeBall(10, 15, 0),
          // 	makeBall(20, 15, 0), makeBall(-28, 15, 0), makeBall(-42, 15, 0), makeBall(0, 30, 0), makeBall(28, 30, 0),
          // 	makeBall(-28, 30, 0)];
          
          var balls = [
              [
                  makeBall(-15, 160, 10, 1),
                  makeBall(-15, 170, 10, 2),
                  makeBall(-15, 180, 10, 3),
                  makeBall(-15, 190, 10, 4),
                  makeBall(-15, 200, 10, 5),
                  makeBall(-15, 210, 10, 6),
                  makeBall(-15, 220, 10, 7),
                  makeBall(-15, 230, 10, 8),
                  makeBall(-15, 240, 10, 9),
                  makeBall(-15, 250, 10, 10),
              ],
              [
                  makeBall(-5, 160, 10, 11),
                  makeBall(-5, 170, 10, 12),
                  makeBall(-5, 180, 10, 13),
                  makeBall(-5, 190, 10, 14),
                  makeBall(-5, 200, 10, 15),
                  makeBall(-5, 210, 10, 16),
                  makeBall(-5, 220, 10, 17),
                  makeBall(-5, 230, 10, 18),
                  makeBall(-5, 240, 10, 19),
                  makeBall(-5, 250, 10, 20),
              ],
              [
                  makeBall(5, 160, 10, 21),
                  makeBall(5, 170, 10, 22),
                  makeBall(5, 180, 10, 23),
                  makeBall(5, 190, 10, 24),
                  makeBall(5, 200, 10, 25),
                  makeBall(5, 210, 10, 26),
                  makeBall(5, 220, 10, 27),
                  makeBall(5, 230, 10, 28),
                  makeBall(5, 240, 10, 29),
                  makeBall(5, 250, 10, 30),
              ],
              [
                  makeBall(15, 160, 10, 31),
                  makeBall(15, 170, 10, 32),
                  makeBall(15, 180, 10, 33),
                  makeBall(15, 190, 10, 34),
                  makeBall(15, 200, 10, 35),
                  makeBall(15, 210, 10, 36),
                  makeBall(15, 220, 10, 37),
                  makeBall(15, 230, 10, 38),
                  makeBall(15, 240, 10, 39),
                  makeBall(15, 250, 10, 40),
              ]
          ];
          
          
          // var stoppers = [
          //     makeStopper(-16),
          //     makeStopper(-5.5),
          //     makeStopper(5.5),
          //     makeStopper(16)
          // ];
          
          let frontWall = makeContainer();
          
          makeGlass();
          makeStopper();
          
          let speed = 0;

          makeTubes();
          
          makeBallsExit();

          makeCatchingBox();
          
          var iteration = 0;

          var topWall = makeTopWall();
          // frontWall.add(topWall);
          // console.log(topWall === scene.getObjectById( 72, true ));
          
          function startGame() {
              // frontWall.rotation.z = Math.PI;
              // console.log(frontWall.rotation.z);
              
              balls[iteration].forEach((item => {
                  scene.add(item);
              }));
              
              if (iteration){
                  // console.log(iteration);
                  frontWall.remove(topWall);
                  scene.add(frontWall);
              }
              
              // console.log(iteration);
              
              // scene.remove(stoppers[iteration]);

              // push 10 balls to container, start rotating
              setTimeout(() => {
                  
                  frontWall.add(topWall);
                  scene.add(frontWall);
                  // scene.add(frontWall);
                  // scene.add(frontWall);

                  // balls.forEach((item) => {
                  //     item.restitution = 0.8;
                  // });

                  scene.setGravity(new THREE.Vector3(0, -400, 0));

                  let timer = setInterval(() => {
                      speed += 0.02;
                      if (speed >= 0.12) {
                          clearInterval(timer);
                      }
                  }, 500)
              }, 2500);

              // pull winning ball, stop rotating
              setTimeout(() => {
                  
                  let winningBall = winningBalls[iteration] - 1 - iteration * 10;

                  scene.remove(balls[iteration][winningBall]);
                  balls[iteration][winningBall].position.z = 48;
                  balls[iteration][winningBall].position.y = -50;
                  balls[iteration][winningBall].position.x = 0;
                  scene.add(balls[iteration][winningBall]);

                  var index = balls[iteration].indexOf(balls[iteration][winningBall]);
                  if (index !== -1) balls[iteration].splice(index, 1);
                  // console.log(balls);

                  setTimeout(() => {

                      var timerB = setInterval(() => {

                          if (balls[iteration].length === 0) {
                              clearInterval(timerB);
                              let timer = setInterval(() => {
                                  if (speed > 0.05) {
                                      speed -= 0.05;
                                  }
                                  // console.log('auto - ', frontWall.rotation.z);
                                  if (frontWall.rotation.z <= 0.3 && frontWall.rotation.z >= -0.3) {
                                      speed = 0;

                                      frontWall.rotation.z = -0.2;

                                      // scene.remove(frontWall);
                                      // frontWall.rotation.z = 0;
                                      // scene.add(frontWall);
                                      clearInterval(timer);
                                      if (iteration < 4) {
                                          // balls[iteration].forEach((item, index) => {
                                          //     if (index !== winningBall) {
                                          //         scene.remove(item);
                                          //     }
                                          // });
                                          // frontWall.rotation.z = 0;
                                          iteration += 1;
                                          // scene.setGravity(new THREE.Vector3(0, -800, 0));
                                          if (iteration === 4) {
                                              return;
                                          }
                                          startGame();
                                      }
                                  }
                              }, 500);
                          } else {
                              scene.remove(balls[iteration][0]);
                              balls[iteration][0].position.z = -20;
                              balls[iteration][0].position.x = 0;
                              balls[iteration][0].position.y = -30;
                              scene.add(balls[iteration][0]);
                              setTimeout(() => {
                                  scene.remove(balls[iteration][0]);
                                  balls[iteration].splice(0, 1);
                              }, 400);
                              
                              //
                          }

                      }, 500);


                  }, 500)
              }, 12000)
          };
      

          const startBtn = document.querySelector('.start_btn');
          startBtn.addEventListener('click', startGame);

          render = function () {
              requestAnimationFrame(render);

              frontWall.rotation.z += speed;
              
              // console.log(frontWall.rotation.z);
              frontWall.__dirtyRotation = true;
              
              // if(removableBall) {
              //     scene.remove(removableBall);
              //     if (removableBall.position.z > -21 && removableBall.position.z < -19) {
              //         removableBall.position.z = -20;
              //         posZ = true;
              //     } else if (removableBall.position.z < -21) {
              //         removableBall.position.z += 1;
              //         posZ = false;
              //     } else if (removableBall.position.z > -19) {
              //         removableBall.position.z -= 1;
              //         posZ = false;
              //     }
              //
              //     if (removableBall.position.x > -1 && removableBall.position.x < 1) {
              //         removableBall.position.x = 0;
              //         posX = true
              //     } else if (removableBall.position.x < -1) {
              //         removableBall.position.x += 1;
              //         posX = false;
              //     } else if (removableBall.position.x > 1) {
              //         removableBall.position.x -= 1;
              //         posX = false
              //     }
              //
              //     if (removableBall.position.y > -31 && removableBall.position.y < -29) {
              //         removableBall.position.y = -30;
              //         posY = true;
              //     } else if (removableBall.position.y > -29) {
              //         removableBall.position.y -= 1;
              //         posY = false;
              //     } else if (removableBall.position.y < -31) {
              //         removableBall.position.y += 1;
              //         posY = false;
              //     }
              //
              //     if (posX && posY && posZ) {
              //         balls.splice(0, 1);
              //         console.log(balls);
              //         removableBall = null;
              //         posX = false;
              //         posY = false;
              //         posZ = false;
              //     } else {
              //         scene.add(removableBall);
              //     }
              //
              //
              // }

              // scene.remove(removableBall);
              // removableBall.position.z = -20;
              // removableBall.position.x = 0;
              // removableBall.position.y = -30;
              // scene.add(removableBall);
              //

              renderer.render(scene, camera);

          };
      requestAnimationFrame(render);
      scene.simulate();
      };

      window.onload = initScene;
      
      function makeStopper(x) {
          var ground_material = Physijs.createMaterial(
              new THREE.MeshPhongMaterial({
                  color: 'red',
                  opacity: 0,
                  transparent: true,
                  side: THREE.DoubleSide,
              }),
              0.9,
              0);

          var stopper = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(10, 10, 1),
              ground_material,
              0, // mass
          );
          
          stopper.rotation.x = Math.PI / 2;
          stopper.position.y = 60;
          stopper.position.z = 10;
          stopper.position.x = x;
          
          scene.add(stopper);
          
          return stopper;
      }
      
      function makeCatchingBox() {
          var ground_material = Physijs.createMaterial(
              new THREE.MeshPhongMaterial({
                  color: 'black',
                  opacity: 1,
                  transparent: true,
                  side: THREE.DoubleSide,
              }),
              0.9,
              0);

          var floor = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(50, 50, 1),
              ground_material,
              0, // mass
          );
          floor.position.z = -35;
          floor.rotation.x = Math.PI / 2;
          floor.position.y = -60;

          var wall = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(50, 60, 1),
              ground_material,
              0, // mass
          );
          
          wall.position.y = -25;
          wall.position.z = -30;
          wall.rotation.x = Math.PI / 2;
          
          var rightWall = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(50, 50, 1),
              ground_material,
              0, // mass
          );

          rightWall.rotation.y = Math.PI / 2;
          rightWall.position.x = -25;
          // floor.add()
          
          var leftWall = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(50, 50, 1),
              ground_material,
              0, // mass
          );

          leftWall.rotation.y = Math.PI / 2;
          leftWall.position.x = 25;
          
          floor.add(rightWall);
          floor.add(leftWall);
          floor.add(wall);
              
          scene.add(floor);
      }
      
      function makeBallsExit() {
          var ground_material = Physijs.createMaterial(
              new THREE.MeshPhongMaterial({
                  color: 'red',
                  opacity: 0,
                  transparent: true,
                  side: THREE.DoubleSide,
              }),
              0.9,
              0);
          

          var floor = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(50, 10, 1),
              ground_material,
              0 // mass
          );

          floor.position.y = -62;
          floor.position.z = 46;
          floor.position.x = -20;
          
          floor.rotation.x = Math.PI / 2;
          floor.rotation.y = Math.PI / 30;
          
          var frontWall = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(50, 10, 1),
              ground_material,
              0 // mass
          );

          frontWall.position.y = 5;
          frontWall.position.z = -5;
          // backWall.position.x = -20;

          frontWall.rotation.x = Math.PI / -2;
          
          var backWall = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(50, 10, 1),
              ground_material,
              0 // mass
          );
          
          backWall.position.z = -5;
          backWall.position.y = -5;
          backWall.rotation.x = Math.PI / -2;


          var stopWall = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(10, 10, 1),
              ground_material,
              0 // mass
          );

          stopWall.position.z = -5;
          stopWall.position.x = -25;
          stopWall.position.y = 0;
          stopWall.rotation.x = Math.PI / -2;
          stopWall.rotation.y = Math.PI / 2;
          
          
          floor.add(backWall);
          floor.add(frontWall);
          floor.add(stopWall);
          
          scene.add(floor);
      }

      function makeTubes() {
          var ground_material = Physijs.createMaterial(
              new THREE.MeshPhongMaterial({
                  color: 'green',
                  opacity: 0,
                  transparent: true,
                  side: THREE.DoubleSide,
              }),
              0.9,
              0);

          var frontWallTube = new Physijs.BoxMesh(
              new THREE.BoxGeometry(40, 110, 1),
              ground_material,
              0 // mass
          );
          
          frontWallTube.position.y = 95;
          frontWallTube.position.z = 5;

          var backWallTube = new Physijs.BoxMesh(
              new THREE.BoxGeometry(40, 110, 1),
              ground_material,
              0 // mass
          );

          backWallTube.position.z = 10;

          var rightWallTube = new Physijs.BoxMesh(
              new THREE.BoxGeometry(10, 110, 1),
              ground_material,
              0 // mass
          );

          rightWallTube.position.x = 10;
          rightWallTube.position.z = 5;
          rightWallTube.rotation.y = Math.PI / 2;
          
          var theMostRightWall = rightWallTube.clone();
          theMostRightWall.position.x = 20;
          
          var theMostLeftWall = rightWallTube.clone();
          theMostLeftWall.position.x = -20;
          
          var centerWallTube = rightWallTube.clone();
          centerWallTube.position.x = 0;

          var leftWallTube = rightWallTube.clone();
          leftWallTube.position.x = -10;

          frontWallTube.add(backWallTube);
          frontWallTube.add(rightWallTube);
          frontWallTube.add(centerWallTube);
          frontWallTube.add(leftWallTube);
          frontWallTube.add(theMostRightWall);
          frontWallTube.add(theMostLeftWall);

          scene.add(frontWallTube);
      }


      function createCylinder() {

          var ground_material = Physijs.createMaterial(
              new THREE.MeshPhongMaterial({
                  color: 'green',
                  opacity: 0.1,
                  transparent: true,
                  side: THREE.DoubleSide,
              }),
              0.9,
              0);

          var extrudeSettings = {
              amount: 40,
              steps: 1,
              bevelEnabled: false,
              curveSegments: 32
          };

          var arcShape = new THREE.Shape();
          arcShape.absarc(0, 0, 50, 0, Math.PI * 2, 40, false);

          var holePath = new THREE.Path();
          holePath.absarc(0, 0, 48, 0, Math.PI * 2, true);
          arcShape.holes.push(holePath);


          var geometry = new THREE.ExtrudeGeometry(arcShape, extrudeSettings);

          var cylinder = new THREE.Mesh(
              geometry,
              ground_material,
              0 // mass
          );

          scene.add(cylinder);

          return cylinder;
      }
      
      function makeTopWall() {
          var ground_material = Physijs.createMaterial(
              new THREE.MeshPhongMaterial({
                  color: 'orange',
                  opacity: 0,
                  transparent: true,
                  side: THREE.DoubleSide,
              }),
              0.4,
              0.8);
          
          var topWall = new Physijs.BoxMesh(
              new THREE.BoxGeometry(50, 40, 4),
              ground_material,
              0 // mass
          );
          topWall.position.y = 50;
          topWall.position.z = 20;
          topWall.rotation.x = Math.PI / 2;

          var smasherTop = new Physijs.BoxMesh(
              new THREE.BoxGeometry(10, 10, 40),
              ground_material,
              0 // mass
          );
          
          // smasherTop.position.y = 45;
          smasherTop.position.z = 5;
          smasherTop.rotation.x = Math.PI / 2;
          topWall.add(smasherTop);
          
          

          var leftCornerTop = new Physijs.BoxMesh(
              new THREE.BoxGeometry(45, 40, 4),
              ground_material,
              0 // mass
          );

          leftCornerTop.rotation.y = Math.PI / 4;
          leftCornerTop.position.x = -35;
          leftCornerTop.position.z = 15;

          topWall.add(leftCornerTop);
          
          var rightCornerTop = leftCornerTop.clone();
          rightCornerTop.rotation.y = Math.PI / -4;
          rightCornerTop.position.x = 35;
          rightCornerTop.position.z = 15;

          topWall.add(rightCornerTop);
          
          // scene.add(topWall);
          
          return topWall;
          
      }

      function makeContainer() {
          var ground_material = Physijs.createMaterial(
              new THREE.MeshPhongMaterial({
                  color: 'green',
                  opacity: 0,
                  transparent: true,
                  side: THREE.DoubleSide,
              }),
              0.4,
              0.7);

          var smasher_material = Physijs.createMaterial(
              new THREE.MeshPhongMaterial({
                  color: 'white',
                  // opacity: 1,true,
                  // transparent:
                  // side: THREE.DoubleSide,
              }),
              0.4,
              0.8);

          ground = new Physijs.BoxMesh(
              new THREE.BoxGeometry(50, 40, 4),
              ground_material,
              0 // mass
          );
          ground.rotation.x = Math.PI / -2;
          ground.position.y = -50;
          ground.position.z = 20;
          //
          var topWall = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(100, 40, 1),
              ground_material,
              0 // mass
          );
          topWall.position.y = 50;
          topWall.position.z = 20;
          topWall.rotation.x = Math.PI / 2;
          //
          var frontWall = new Physijs.BoxMesh(
              new THREE.BoxGeometry(100, 100, 4),
              ground_material,
              0 // mass
          );
          frontWall.position.z = 0;
          frontWall.rotation.z = 0.1;
          // frontWall.position.x = 0;

          // frontWall.rotation.x = Math.PI / 2;

          var backWall = new Physijs.BoxMesh(
              new THREE.BoxGeometry(100, 100, 4),
              ground_material,
              0 // mass
          );
          backWall.position.z = 40;

          var rightWall = new Physijs.BoxMesh(
              new THREE.BoxGeometry(40, 100, 4),
              ground_material,
              0 // mass
          );
          rightWall.position.x = 50;
          rightWall.position.z = 20;
          rightWall.rotation.y = Math.PI / 2;

          var leftWall = new Physijs.BoxMesh(
              new THREE.BoxGeometry(40, 100, 4),
              ground_material,
              0 // mass
          );
          leftWall.position.x = -50;
          leftWall.position.z = 20;
          leftWall.rotation.y = Math.PI / 2;

          var leftCorner = new Physijs.BoxMesh(
              new THREE.BoxGeometry(45, 40, 4),
              ground_material,
              0 // mass
          );

          leftCorner.rotation.x = Math.PI / -2;
          leftCorner.rotation.y = Math.PI / 4;
          leftCorner.position.x = -35;
          leftCorner.position.y = -35;
          leftCorner.position.z = 20;

          var leftCornerTop = new Physijs.BoxMesh(
              new THREE.BoxGeometry(45, 40, 4),
              ground_material,
              0 // mass
          );

          leftCornerTop.rotation.x = Math.PI / -2;
          leftCornerTop.rotation.y = Math.PI / 4;
          leftCornerTop.position.x = 35;
          leftCornerTop.position.y = 35;
          leftCornerTop.position.z = 20;
          //
          var rightCorner = new Physijs.BoxMesh(
              new THREE.BoxGeometry(45, 40, 4),
              ground_material,
              0 // mass
          );

          rightCorner.rotation.x = Math.PI / 2;
          rightCorner.rotation.y = Math.PI / 4;

          rightCorner.position.x = 35;
          rightCorner.position.y = -35;
          rightCorner.position.z = 20;

          var rightCornerTop = new Physijs.BoxMesh(
              new THREE.BoxGeometry(45, 40, 4),
              ground_material,
              0 // mass
          );

          rightCornerTop.rotation.x = Math.PI / 2;
          rightCornerTop.rotation.y = Math.PI / 4;

          rightCornerTop.position.x = -35;
          rightCornerTop.position.y = 35;
          rightCornerTop.position.z = 20;


          var smasherBottom = new Physijs.BoxMesh(
              new THREE.BoxGeometry(10, 10, 40),
              ground_material,
              0 // mass
          );

          smasherBottom.position.z = 20;
          smasherBottom.position.y = -46;

          var smasherTop = smasherBottom.clone();
          smasherTop.position.y = 46;

          var smasherLeft = smasherBottom.clone();
          smasherLeft.position.x = -46;
          smasherLeft.position.y = 0;

          var smasherRight = smasherLeft.clone();
          smasherLeft.position.x = 46;

          var FakeSmasherBottom = new THREE.Mesh(
              new THREE.BoxGeometry(10, 0.5, 40, 32),
              smasher_material,
              0 // mass
          );

          FakeSmasherBottom.position.z = 20;
          FakeSmasherBottom.position.y = -40;
          FakeSmasherBottom.rotation.z = Math.PI / 2;

          var fakeSmasherTop = FakeSmasherBottom.clone();
          fakeSmasherTop.position.y = 40;

          var fakeSmasherLeft = FakeSmasherBottom.clone();
          fakeSmasherLeft.rotation.z = Math.PI;
          fakeSmasherLeft.position.x = 40;
          fakeSmasherLeft.position.y = 0;

          var fakeSmasherRight = FakeSmasherBottom.clone();
          fakeSmasherRight.rotation.z = Math.PI;
          fakeSmasherRight.position.x = -40;
          fakeSmasherRight.position.y = 0;

          var mainAxe = new Physijs.CylinderMesh(
              new THREE.CylinderGeometry(0.5, 0.5, 90, 32),
              smasher_material,
              0 // mass
          );

          mainAxe.position.z = -1;

          var addAxe = mainAxe.clone();
          addAxe.rotation.z = Math.PI / 2;

          var centerAxe = new Physijs.CylinderMesh(
              new THREE.CylinderGeometry(1, 1, 40, 32),
              smasher_material,
              0 // mass
          );
          centerAxe.rotation.x = Math.PI / 2;
          centerAxe.position.z = 20;

          mainAxe.add(addAxe);


          //
          // frontWall.add( topWall );
          frontWall.add(ground);
          frontWall.add(backWall);
          frontWall.add(rightWall);
          frontWall.add(leftWall);
          frontWall.add(leftCorner);
          // frontWall.add(leftCornerTop);
          frontWall.add(rightCorner);
          // frontWall.add(rightCornerTop);
          frontWall.add(smasherBottom);
          // frontWall.add(smasherTop);
          frontWall.add(smasherLeft);
          frontWall.add(smasherRight);
          frontWall.add(mainAxe);
          frontWall.add(centerAxe);
          frontWall.add(FakeSmasherBottom);
          frontWall.add(fakeSmasherTop);
          frontWall.add(fakeSmasherLeft);
          frontWall.add(fakeSmasherRight);

          scene.add(frontWall);

          // createCylinder();

          return frontWall;
      }

      function makeBall(x, y, z, imageNum) {
          // const loader = new THREE.TextureLoader();
          // var geometry = new THREE.SphereGeometry(4, 32, 32);

          // var material = new THREE.MeshBasicMaterial({color: 0xFFFFFF});
          // var texture = THREE.ImageUtils.loadTexture("assets/126.png");
          // material.map = texture;

          var geometry = new THREE.BoxGeometry( 1, 1, 1, 12, 12, 12 );
          for ( var i in geometry.vertices ) {
              var vertex = geometry.vertices[ i ];
              vertex.normalize().multiplyScalar(4);
          }

          var image = document.createElement( 'img' );
          image.src = `assets/balls/${imageNum}.png`;

          var texture = new THREE.Texture( image );
          image.addEventListener( 'load', function ( event ) {
              texture.needsUpdate = true;
              console.log('loaded');
          } );


          var sideMaterial = Physijs.createMaterial(
              new THREE.MeshBasicMaterial({
                  color: 0xffffff,
                  // specular: 0x505050,
                  // shininess: 150,
                  map: texture
              }),
              0.4,
              0.6,
          );
          
          var materialArray = [];

          for (let i = 0; i < 6; i++) {
              materialArray.push(sideMaterial);
          }

          // var material = new THREE.MeshFaceMaterial(materialArray);
          //
          // var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
          // for ( let i = 0; i < faceVertexUvs.length; i ++ ) {
          //
          //     var uvs = faceVertexUvs[ i ];
          //     var face = geometry.faces[ i ];
          //
          //     for ( var j = 0; j < 3; j ++ ) {
          //
          //         uvs[ j ].x = face.vertexNormals[ j ].x * 0.5 + 0.5;
          //         uvs[ j ].y = face.vertexNormals[ j ].y * 0.5 + 0.5;
          //
          //     }
          //
          // }


          
          
          // material.wrapS = THREE.RepeatWrapping;

          // material.shininess = 150;
          // var material = new THREE.MeshFaceMaterial(materialArray);
          
          var ball = new Physijs.SphereMesh(geometry, sideMaterial, 7);
          ball.position.x = x;
          ball.position.y = y;
          ball.position.z = z;
          ball.castShadow = true;

          // scene.add(ball);

          return ball;
      }
      
      function setWinningBalls(firstBall, secondBall, thirdBall, fourthBall) {
          winningBalls = [firstBall, secondBall, thirdBall, fourthBall]
      }
      
    function makeGlass() {
        var material = new THREE.MeshBasicMaterial({
            map: THREE.ImageUtils.loadTexture('assets/Glass.png'),
            transparent: true,
            opacity: 1,
            color: 0xFFFFFF
        });

        var glass = new Physijs.BoxMesh(
            new THREE.PlaneGeometry(100, 182, 1),
            material,
            0 // mass
        );
        
        glass.position.z = 52;
        glass.position.y = 27;

        var bodyMaterial = new THREE.MeshBasicMaterial({
            map: THREE.ImageUtils.loadTexture('assets/Body.png'),
            transparent: true,
            opacity: 1,
            color: 0xFFFFFF
        });

        var body = new Physijs.BoxMesh(
            new THREE.PlaneGeometry(118, 263, 1),
            bodyMaterial,
            0 // mass
        );

        body.position.z = -5;
        body.position.y = 17;
        body.position.x = -2;
        
        scene.add(glass);
        scene.add(body);
    }
  
  </script>
</head>

<body>
<div id="viewport"></div>
<button class="start_btn" style="position: absolute; top: 10px; left: 10px;">Start</button>
</body>

</html>
