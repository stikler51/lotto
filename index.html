<!DOCTYPE html>

<html>

<head>
  <title>Star99</title>
  
  <link rel="stylesheet" type="text/css" href="js/physijs/examples/css/styles.css"/>
  <link rel="stylesheet" type="text/css" href="style.css"/>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r83/three.js"></script>
  <script type="text/javascript" src="js/physijs/physi.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/md5.js"></script>
  
  <script type="text/javascript">
      Physijs.scripts.worker = 'js/physijs/physijs_worker.js';
      Physijs.scripts.ammo = 'examples/js/ammo.js';

      var initScene, render, loader, renderer, scene, ground, camera;
      
      // Здесь хранится номер раунда. Нумерация идет с конца, т.к. апи выдает результаты в обратном порядке
      let round = 23; 
      let winningBallsAllRounds;

      initScene = async function () {
          
          // Делаем запрос к апи, сохраняем ответ в виде объекта в winningBallsAllRounds
          winningBallsAllRounds = await getWinningBalls()
              .then(data => data);
          // Для проверки выводим этот объект в консоль
          console.log(winningBallsAllRounds);
          
          
          //Здесь стандартные процедуры для инициализации three.js 
          renderer = new THREE.WebGLRenderer({antialias: true});
          
          // Размер канваса, в котором рендерится сцена
          renderer.setSize(1366, 768);
          renderer.setClearColor('black');
          renderer.powerPreference = 'high-performance';
          renderer.shadowMap.enabled = false;
          renderer.shadowMapSoft = false;
          document.getElementById('viewport').appendChild(renderer.domElement);
          
          scene = new Physijs.Scene;
          scene.background = 'black';
          
          // Гравитация на сцене. -500 - значение по оси Y. Чем меньше значение - тем сильнее гравитация. 
          // Значение подобрано оптимальное. Его изменение может вызывать проскакивание шаров сквозь барабан при падении
          scene.setGravity(new THREE.Vector3(0, -500, 0));
          scene.addEventListener(
              'update',
              function () {
                  scene.simulate(undefined, 1);
              }
          );

          // Установка позиции камеры
          camera = new THREE.PerspectiveCamera(
              35,
              1366 / 768,
              1,
              1000
          );
          
          // Значение 625 - удаленность камеры от начала координат по оси Z. Это значение нужно уменьшить, если 
          // необходимо все приблизить
          camera.position.set(0, 20, 625);
          camera.lookAt({x: 0, y: 20, Z: 0});
          scene.add(camera);
          
          
          // Если раскоментировать эту строку, появится возможность управлять камерой с помощью мыши. Удобно для отладки
          // Если убрать прозрачность у объектов, то можно увидеть общую структуру сцены: все сделано примитивными фигурами
          // Они находятся друг позади друга,таким образом, с определенного ракурса создается впечатление единства всех объектов
          // var controls = new THREE.OrbitControls(camera, renderer.domElement);

          // Light
          var ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.9); // soft white light (мягкий белый свет)
          scene.add(ambientLight);
          
          // Loader
          loader = new THREE.TextureLoader();
          
          // Массив с шарами, которые создаются при первом запуске
          var balls = [
              [
                  makeBall(-15, 70, 10, 0),
                  makeBall(-15, 80, 10, 1),
                  makeBall(-15, 90, 10, 2),
                  makeBall(-15, 100, 10, 3),
                  makeBall(-15, 110, 10, 4),
                  makeBall(-15, 120, 10, 5),
                  makeBall(-15, 130, 10, 6),
                  makeBall(-15, 140, 10, 7),
                  makeBall(-15, 157, 10, 8),
                  makeBall(-15, 160, 10, 9),
              ],
              [
                  makeBall(-5, 70,  10, 0),
                  makeBall(-5, 80,  10, 1),
                  makeBall(-5, 90,  10, 2),
                  makeBall(-5, 100, 10, 3),
                  makeBall(-5, 110, 10, 4),
                  makeBall(-5, 120, 10, 5),
                  makeBall(-5, 130, 10, 6),
                  makeBall(-5, 140, 10, 7),
                  makeBall(-5, 157, 10, 8),
                  makeBall(-5, 160, 10, 9),
              ],
              [
                  makeBall(5, 70,  10, 0),
                  makeBall(5, 80,  10, 1),
                  makeBall(5, 90,  10, 2),
                  makeBall(5, 100, 10, 3),
                  makeBall(5, 110, 10, 4),
                  makeBall(5, 120, 10, 5),
                  makeBall(5, 130, 10, 6),
                  makeBall(5, 140, 10, 7),
                  makeBall(5, 157, 10, 8),
                  makeBall(5, 160, 10, 9),
              ],
              [
                  makeBall(15, 70, 10, 0),
                  makeBall(15, 80, 10, 1),
                  makeBall(15, 90, 10, 2),
                  makeBall(15, 100, 10, 3),
                  makeBall(15, 110, 10, 4),
                  makeBall(15, 120, 10, 5),
                  makeBall(15, 130, 10, 6),
                  makeBall(15, 140, 10, 7),
                  makeBall(15, 157, 10, 8),
                  makeBall(15, 160, 10, 9),
              ]
          ];
          
          // Функция, которая заменят шары при каждом новом раунде
          function ballPull() {
              return [
                  [
                      makeBall(-15, 137, 10, 0),
                      makeBall(-15, 137, 10, 1),
                      makeBall(-15, 137, 10, 2),
                      makeBall(-15, 137, 10, 3),
                      makeBall(-15, 137, 10, 4),
                      makeBall(-15, 137, 10, 5),
                      makeBall(-15, 137, 10, 6),
                      makeBall(-15, 137, 10, 7),
                      makeBall(-15, 137, 10, 8),
                      makeBall(-15, 137, 10, 9)
                  ],
                  [
                      makeBall(-5, 137, 10, 0),
                      makeBall(-5, 137, 10, 1),
                      makeBall(-5, 137, 10, 2),
                      makeBall(-5, 137, 10, 3),
                      makeBall(-5, 137, 10, 4),
                      makeBall(-5, 137, 10, 5),
                      makeBall(-5, 137, 10, 6),
                      makeBall(-5, 137, 10, 7),
                      makeBall(-5, 137, 10, 8),
                      makeBall(-5, 137, 10, 9)
                  ],
                  [
                      makeBall(5, 137, 10, 0),
                      makeBall(5, 137, 10, 1),
                      makeBall(5, 137, 10, 2),
                      makeBall(5, 137, 10, 3),
                      makeBall(5, 137, 10, 4),
                      makeBall(5, 137, 10, 5),
                      makeBall(5, 137, 10, 6),
                      makeBall(5, 137, 10, 7),
                      makeBall(5, 137, 10, 8),
                      makeBall(5, 137, 10, 9)
                  ],
                  [
                      makeBall(15, 137, 10, 0),
                      makeBall(15, 137, 10, 1),
                      makeBall(15, 137, 10, 2),
                      makeBall(15, 137, 10, 3),
                      makeBall(15, 137, 10, 4),
                      makeBall(15, 137, 10, 5),
                      makeBall(15, 137, 10, 6),
                      makeBall(15, 137, 10, 7),
                      makeBall(15, 137, 10, 8),
                      makeBall(15, 137, 10, 9)

                  ]
              ];
          }
          
          // Массив с перегородками, которые не дают падать шарам в трубах
          var stoppers = [
              makeStopper(-15),
              makeStopper(-5),
              makeStopper(5),
              makeStopper(15)
          ];
          
          // Вращающийся барабан
          let container = makeContainer();

          // Стенка с бэкграундом позади всех объектов
          makeSceneBg();
          
          // Объекты с текстурами автомата
          makeGlass();
          
          // Трубы сверху, удерживающие шары
          makeTubes();
          
          // Трубка снизу, в которую выкатывается выирышный шар
          makeBallsExit();

          // Ящик за автоматом, куда падают все шары. Нужен, чтобы шары не падали вникуда
          makeCatchingBox();

          // Верхняя стенка цилиндра. Удаляется и снова добавляется, чтобы шары могли упасть в барабан и не вываливаться из него
          var topWall = makeTopWall();
          
          // Всего 4 итерации (по количеству трубок с шарами)
          var iteration = 0;
          
          // Порядковый номер шара. Используется в функциях добавления / удаления шаров на сцену / со сцены
          let ballNum = 0;
          
          // Массив с выигрышными номерами шаров
          let winningBallsPull = [];
          
          // Скорость вращения барабана
          let speed = 0;
          
          // Добавление первого массива шаров в трубки
          balls.forEach((item => {
              item.forEach((ball => {
                  scene.add(ball);
              }))
          }));
          
          // Функция добавления шаров на сцену
          function addBallsToScene() {
              for (let j = 0; j < 4; j++) {
                  scene.add(balls[j][ballNum])
              }
          };

          // Вставка видео
          let vid = document.createElement('video');
          vid.src = 'output.webm';

          // Функция удаления выигрышных шаров со сцены. Если их не удалять, то к раунду 10, компу становится больно
          function removeWinnigBalls(ball) {
              scene.remove(ball);
              ball.position.z = -10;
              scene.add(ball);
              
              setTimeout(()=> {
                  scene.remove(ball);
              }, 500);
          };
          
          // Главная функция, где прописана вся логика и тайминги игры
          function startGame() {
              // Сохраняем в массив выигрышные шары конкретного раунда
              let winningBalls = winningBallsAllRounds[round].split('');

              // Удаляется верхняя часть барабана, чтобы шары могли в него упасть
              container.remove(topWall);
              // Обновление сцены с удаленной верхней частью барабана
              scene.add(container);
              // Удаляется стоппер из трубки, чтобы шары могли упасть
              scene.remove(stoppers[iteration]);

              // через 2,5 сек снова добавляется верхняя часть барабана
              setTimeout(() => {
                  container.add(topWall);
                  scene.add(container);
                  
                  // корректируется гравитация.
                  scene.setGravity(new THREE.Vector3(0, -400, 0));

                  // Каждые 0.5 сек скорость вращения барабана увеличивается на 0,02
                  let timer = setInterval(() => {
                      speed += 0.02;
                      if (speed >= 0.12) {
                          clearInterval(timer);
                      }
                  }, 500)
              }, 2500);

              // через 12 секунд после начала раунда выпадает выигрышшный шар
              setTimeout(() => {
                  // определяется выигрышный шар для этого раунда, этой итерации
                  let winningBall = winningBalls[iteration];
                  
                  // изменяется положение шара в пространстве, чтобы перенести его в нижнюю трубку
                  scene.remove(balls[iteration][winningBall]);
                  balls[iteration][winningBall].position.z = 48;
                  balls[iteration][winningBall].position.y = -50;
                  balls[iteration][winningBall].position.x = 0;
                  scene.add(balls[iteration][winningBall]);

                  // выигрышный шар сохраняется в отдельном массиве, чтобы потом была возможность его удадить
                  winningBallsPull[iteration] = balls[iteration][winningBall];
                  // Добавляется картинка в нижней части сцены с выпавшим шаром
                  let ballCont = document.body.querySelector(`.winning-${iteration}`);
                  let img = document.createElement('img');
                  img.src = `assets/balls/balls/Ball_${winningBall}.png`;
                  ballCont.appendChild(img);
                  
                  // выигрышный шар удаляется из массива со всеми шарами, чтобы можно было без проблем потом удалить остальные
                  var index = balls[iteration].indexOf(balls[iteration][winningBall]);
                  if (index !== -1) balls[iteration].splice(index, 1);
                  
                  // Через 0.5 сек вращение барабана начинает замедляться
                  setTimeout(() => {
                      // Каждые 0.5 сек удаляется один невыигрышный шар
                      var timerB = setInterval(() => {
                          
                          // Когда все шары удалятся, запускается эта часть
                          if (balls[iteration].length === 0) {
                              clearInterval(timerB);
                              
                              // Каждые 0.2 сек проверяется положение барабана
                              let timer = setInterval(() => {
                                  
                                  // Вращение барабана замедляется
                                  if (speed > 0.06) {
                                      speed -= 0.05;
                                  }
                                  
                                  // Барабан вертится с небольной скоростью, пока его верхняя стенка, которая
                                  // должна удаляться, не будет смотреть вверх
                                  if (container.rotation.z <= 0.3 && container.rotation.z >= -0.3) {
                                      // Как только барабан в нужном положении, полностью останавливаем его
                                      speed = 0;
                                      container.rotation.z = 0;
                                      
                                      // прекращаем проверку положения барабана
                                      clearInterval(timer);
                                      
                                      // Если количество итераций достигло 4, выполнение функции прекращается,
                                      // ожидается нажатие кнопки старт для начала следующего раунда
                                      if (iteration < 4) {
                                          // в противном случае счетчик итераций увеличивается и вызывается
                                          // startGame с новой итерацией
                                          iteration += 1;
                                          if (iteration === 4) {
                                              // Если итерация = 4, значит раунд завершен
                                              setTimeout(() => {
                                                  // через 0,5сек удаляются картинки с выигрышными шарами внизу сцены
                                                  document.body.querySelectorAll('.win').forEach(item => {
                                                      item.innerHTML = '';
                                                  });
                                                  
                                                  // Выигрышные числа переносятся в таблицы по бокам
                                                  let winStr = `${winningBalls[0]} ${winningBalls[1]} ${winningBalls[2]} ${winningBalls[3]}`;
                                                  document.body.querySelectorAll(`.round-${round}`).forEach(item => {
                                                    item.innerHTML = winStr;
                                                  });
                                                  
                                                  // изменяется счетчик раундов
                                                  round -= 1;
                                                  if (round < 1) {
                                                      // все заканчивается, когда счетчик раундов доходит до 0
                                                      return;
                                                  }

                                                  // Удаляются выигршыне шары со сцены каждые 0,5сек
                                                  winningBalls = winningBallsAllRounds[round].split('');
                                                  let ballNum = 0;
                                                  let removeWinBalls = setInterval(() => {
                                                      removeWinnigBalls(winningBallsPull[ballNum]);
                                                      ballNum++;
                                                      if(ballNum >= 4) {
                                                          clearInterval(removeWinBalls);
                                                          ballNum = 0;
                                                      }
                                                  }, 500);
                                              }, 500);
                                              
                                              // через 3 секунды сцена подготавливается к новому раунду
                                              setTimeout(() => {
                                                  
                                                  // На сцену добавляются стопперы в трубки, чтобы шары не падали в барабан
                                                  stoppers.forEach((item) => {
                                                      scene.add(item);
                                                  });
                                                  
                                                  // В трубки добавляются новые шары каждые 0.25сек
                                                  balls = ballPull();
                                                  let int = setInterval(() => {
                                                      addBallsToScene();
                                                      ballNum++;
                                                      if(ballNum >= 10) {
                                                          clearInterval(int);
                                                          ballNum = 0;
                                                      }
                                                  }, 250);
                                                  // обнуляется счетчик итераций для нового раунда
                                                  iteration = 0;
                                                  
                                                  // через 4 сек запускается новый раунд
                                                  setTimeout(() => {
                                                      startGame();
                                                  }, 4000);
                                              }, 3000)
                                          } else {
                                              // Начало игры с новой итерацией, если iteration < 4
                                              startGame();
                                          }
                                      }
                                  }
                              }, 200);
                          } else {
                              // Удаление шаров из барабана в конце кжадой итерации
                              scene.remove(balls[iteration][0]);
                              balls[iteration][0].position.z = -20;
                              balls[iteration][0].position.x = 0;
                              balls[iteration][0].position.y = -30;
                              scene.add(balls[iteration][0]);
                              setTimeout(() => {
                                  scene.remove(balls[iteration][0]);
                                  balls[iteration].splice(0, 1);
                              }, 400);
                          }
                      }, 500);
                  }, 500)
              }, 12000)
          };
          
          // Запуск раунда по нажатию кнопки Start
          const startBtn = document.querySelector('.start_btn');
          
          startBtn.addEventListener('click', () => {
              //запуск видео через 5 сек после загрузки игры, чтобы все успело прогрузиться
                      document.getElementById('viewport').appendChild(vid);
                      setTimeout(() => {
                          document.body.querySelector('video').play();
                      }, 1000);
              
              // удаление видео после окончания его воспроизведения
              vid.addEventListener('ended', () => {
                  vid.remove();
                  startGame();
              });
          });
          
          const fullscreenBtn = document.querySelector('.fullscreen_btn');
          const canvas = document.querySelector('.container');

          fullscreenBtn.addEventListener('click', () => {
              canvas.requestFullscreen();
          });

          // window.addEventListener("keyup", function(event) {
          //     // Number 13 is the "Enter" key on the keyboard
          //     if (event.keyCode === 13) {
          //         // Cancel the default action, if needed
          //         event.preventDefault();
          //         // Trigger the button element with a click
          //         document.querySelector('.start_btn').click();
          //     }
          // });
          
          // Обновление времени на табло вверху каждые 10 сек
          updateTime();
          setInterval(() => {
              updateTime();
          }, 10000);

          // главная функция, без которой three js не работает.
          render = function () {
              requestAnimationFrame(render);
              
              // Вращение барабана создается изменением значения rotation на величину speed
              container.rotation.z += speed;
              container.__dirtyRotation = true;
              
              renderer.render(scene, camera);
          };
          
          // То без чего three js и physi.js не работают. лучше не трогать
          scene.simulate();
          requestAnimationFrame(render);
      };
      
      // Запуск всего, что описано выше при загрузке страницы
      window.onload = initScene;
      
      
      // Ниже описаны вспомогательные функции контрукторы, которые используются для создантия объектов и вызывются в initScene.
      // В них можно изменить физические размеры объектов, поменять их цвет, положение в пространстве.
      // Делать это я не рекомендую, т.к. все подогнано и будет больно все переделывать.
      // Если нужно изменить размер чего либо, рекомендую изменить положение камеры (приблизить или отдалить).
      // Изменять размеры и положение в пространстве для того, чтобы все выглядело реалистично, я рекомендую только в функциях
      // makeSceneBg() и makeGlass(), в которых создаются объекты с текстурами.
      // Во всех остальных допустимо менять только свойство opacity в конструктораз материалов. Так можно будет увидеть,
      // как реально выглядят и где находятся объекты.
      
      // Функция, которая создает опоры для шаров в трубах
      // Все функции-конструкторы примерно одинаковые, поэтому подробно опишу толко эту. В остальных сделаю мелкие примечания
      function makeStopper(x) {
          // Конструктор материала
          var ground_material = Physijs.createMaterial(
              new THREE.MeshBasicMaterial({
                  color: 'red', // цвет
                  opacity: 0, // прозрачность. меняется от 0 до 1. можно установить 0.5, чтобы увидеть где находится объект
                  transparent: true, // разрешает использовать прозрачность
                  side: THREE.DoubleSide, // объект будет виден со всех сторон. По умолчанию он виден только с одной стороны
              }),
              0.9, // Коэфициент трения. Эти параметры важны для взаимодействия шаров с барабаном.
              0); // Коэфициент упругости

          // Конструктор самого объекта. Грубо говоря, задает геометрия и объединяется с материалом
          var stopper = new Physijs.BoxMesh(
              new THREE.BoxBufferGeometry(10, 10, 1),
              ground_material,
              0, // mass
          );
          
          // Настройки положения в пространстве
          stopper.rotation.x = Math.PI / 2;
          stopper.position.y = 58;
          stopper.position.z = 10;
          stopper.position.x = x;
          
          // Так объект рендерится. Если не добавить его на сцену, он просто не отобразится
          scene.add(stopper);
          
          return stopper;
      }
      
      // Функция, которая создает коробку позади для ловли выпадающих шаров
      function makeCatchingBox() {
          var ground_material = Physijs.createMaterial(
              new THREE.MeshBasicMaterial({
                  color: 'black',
                  opacity: 1,
                  transparent: true,
                  side: THREE.DoubleSide,
              }),
              0.9,
              0);

          var floor = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(105, 50, 1),
              ground_material,
              0, // mass
          );
          floor.position.z = -35;
          floor.rotation.x = Math.PI / 2;
          floor.position.y = -90;

          var wall = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(105, 100, 1),
              ground_material,
              0, // mass
          );
          
          wall.position.y = -25;
          wall.position.z = -45;
          wall.rotation.x = Math.PI / 2;
          
          var rightWall = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(50, 50, 1),
              ground_material,
              0, // mass
          );

          rightWall.rotation.y = Math.PI / 2;
          rightWall.position.x = -52;
          rightWall.position.z = -22;
          // floor.add()
          
          var leftWall = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(50, 50, 1),
              ground_material,
              0, // mass
          );

          leftWall.rotation.y = Math.PI / 2;
          leftWall.position.x = 50;
          leftWall.position.z = -22;
          
          // Многие объекты состоят из нескольких более простых объектов.
          // Как правило, из плоскостей и прямоугольнков
          // Чтобы объединить несколько примитивных объектов в сложный, нужно выбрать базовый объект
          // (в данном случае - это floor) и добавить к нему остальные примитивы функцией add
          floor.add(rightWall);
          floor.add(leftWall);
          floor.add(wall);
          
          scene.add(floor);
      }
      
      // Создает трубку снизу, куда выкатываются выигрышные шары
      function makeBallsExit() {
          var ground_material = Physijs.createMaterial(
              new THREE.MeshBasicMaterial({
                  color: 'red',
                  opacity: 0,
                  transparent: true,
                  side: THREE.DoubleSide,
              }),
              0.9,
              0);
          

          var floor = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(50, 10, 1),
              ground_material,
              0 // mass
          );

          floor.position.y = -64;
          floor.position.z = 46;
          floor.position.x = -20;
          floor.rotation.x = Math.PI / 2;
          floor.rotation.y = Math.PI / 30;
          
          var frontWall = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(50, 10, 1),
              ground_material,
              0 // mass
          );

          frontWall.position.y = 5;
          frontWall.position.z = -5;
          frontWall.rotation.x = Math.PI / -2;
          
          var backWall = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(50, 10, 1),
              ground_material,
              0 // mass
          );
          
          backWall.position.z = -5;
          backWall.position.y = -5;
          backWall.rotation.x = Math.PI / -2;
          
          var stopWall = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(10, 10, 1),
              ground_material,
              0 // mass
          );

          stopWall.position.z = -5;
          stopWall.position.x = -25;
          stopWall.position.y = 0;
          stopWall.rotation.x = Math.PI / -2;
          stopWall.rotation.y = Math.PI / 2;
          
          
          floor.add(backWall);
          floor.add(frontWall);
          floor.add(stopWall);
          
          scene.add(floor);
      }

      // Трубки сверху, в которых лежат шары
      function makeTubes() {
          var ground_material = Physijs.createMaterial(
              new THREE.MeshBasicMaterial({
                  color: 'green',
                  opacity: 0,
                  transparent: true,
                  side: THREE.DoubleSide,
              }),
              0.9,
              0);

          var frontWallTube = new Physijs.BoxMesh(
              new THREE.BoxBufferGeometry(40, 110, 1),
              ground_material,
              0 // mass
          );
          
          frontWallTube.position.y = 95;
          frontWallTube.position.z = 5;

          var backWallTube = new Physijs.BoxMesh(
              new THREE.BoxGeometry(40, 110, 1),
              ground_material,
              0 // mass
          );

          backWallTube.position.z = 10;

          var rightWallTube = new Physijs.BoxMesh(
              new THREE.BoxGeometry(10, 110, 2),
              ground_material,
              0 // mass
          );

          rightWallTube.position.x = 10;
          rightWallTube.position.z = 5;
          rightWallTube.rotation.y = Math.PI / 2;
          
          var theMostRightWall = rightWallTube.clone();
          theMostRightWall.position.x = 20;
          
          var theMostLeftWall = rightWallTube.clone();
          theMostLeftWall.position.x = -20;
          
          var centerWallTube = rightWallTube.clone();
          centerWallTube.position.x = 0;

          var leftWallTube = rightWallTube.clone();
          leftWallTube.position.x = -10;

          frontWallTube.add(backWallTube);
          frontWallTube.add(rightWallTube);
          frontWallTube.add(centerWallTube);
          frontWallTube.add(leftWallTube);
          frontWallTube.add(theMostRightWall);
          frontWallTube.add(theMostLeftWall);

          scene.add(frontWallTube);
      }
      
      // Верхняя стенка барабана, которая добавляется и удаляется, когда нужно всыпать шары в барабан
      function makeTopWall() {
          var ground_material = Physijs.createMaterial(
              new THREE.MeshBasicMaterial({
                  color: 'orange',
                  opacity: 0,
                  transparent: true,
                  side: THREE.DoubleSide,
              }),
              0.4,
              0.8);
          
          var topWall = new Physijs.BoxMesh(
              new THREE.BoxBufferGeometry(50, 40, 4),
              ground_material,
              0 // mass
          );
          topWall.position.y = 50;
          topWall.position.z = 20;
          topWall.rotation.x = Math.PI / 2;

          var smasherTop = new Physijs.BoxMesh(
              new THREE.BoxGeometry(10, 10, 40),
              ground_material,
              0 // mass
          );

          smasherTop.position.z = 5;
          smasherTop.rotation.x = Math.PI / 2;
          topWall.add(smasherTop);
          
          var leftCornerTop = new Physijs.BoxMesh(
              new THREE.BoxGeometry(45, 40, 4),
              ground_material,
              0 // mass
          );

          leftCornerTop.rotation.y = Math.PI / 4;
          leftCornerTop.position.x = -35;
          leftCornerTop.position.z = 15;

          topWall.add(leftCornerTop);
          
          var rightCornerTop = leftCornerTop.clone();
          rightCornerTop.rotation.y = Math.PI / -4;
          rightCornerTop.position.x = 35;
          rightCornerTop.position.z = 15;

          topWall.add(rightCornerTop);
          
          return topWall;
      }

      // Барабан
      function makeContainer() {
          var ground_material = Physijs.createMaterial(
              new THREE.MeshBasicMaterial({
                  color: 'green',
                  opacity: 0,
                  transparent: true,
                  side: THREE.DoubleSide,
              }),
              0.4,
              0.9);

          var smasher_material = Physijs.createMaterial(
              new THREE.MeshPhongMaterial({
                  color: 'white',
              }),
              0.4,
              0.9);

          ground = new Physijs.BoxMesh(
              new THREE.BoxBufferGeometry(50, 40, 4),
              ground_material,
              0 // mass
          );
          ground.rotation.x = Math.PI / -2;
          ground.position.y = -50;
          ground.position.z = 20;

          var topWall = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(100, 40, 1),
              ground_material,
              0 // mass
          );
          topWall.position.y = 50;
          topWall.position.z = 20;
          topWall.rotation.x = Math.PI / 2;

          var frontWall = new Physijs.BoxMesh(
              new THREE.BoxBufferGeometry(100, 100, 4),
              ground_material,
              0 // mass
          );
          frontWall.position.z = 0;
          frontWall.rotation.z = 0.1;

          var backWall = new Physijs.BoxMesh(
              new THREE.BoxBufferGeometry(100, 100, 4),
              ground_material,
              0 // mass
          );
          backWall.position.z = 40;

          var rightWall = new Physijs.BoxMesh(
              new THREE.BoxBufferGeometry(40, 60, 4),
              ground_material,
              0 // mass
          );
          rightWall.position.x = 50;
          rightWall.position.z = 20;
          rightWall.rotation.y = Math.PI / 2;

          var leftWall = new Physijs.BoxMesh(
              new THREE.BoxBufferGeometry(40, 60, 4),
              ground_material,
              0 // mass
          );
          leftWall.position.x = -50;
          leftWall.position.z = 20;
          leftWall.rotation.y = Math.PI / 2;

          var leftCorner = new Physijs.BoxMesh(
              new THREE.BoxBufferGeometry(45, 40, 4),
              ground_material,
              0 // mass
          );
          leftCorner.rotation.x = Math.PI / -2;
          leftCorner.rotation.y = Math.PI / 4;
          leftCorner.position.x = -35;
          leftCorner.position.y = -35;
          leftCorner.position.z = 20;

          var leftCornerTop = new Physijs.BoxMesh(
              new THREE.BoxBufferGeometry(45, 40, 4),
              ground_material,
              0 // mass
          );
          leftCornerTop.rotation.x = Math.PI / -2;
          leftCornerTop.rotation.y = Math.PI / 4;
          leftCornerTop.position.x = 35;
          leftCornerTop.position.y = 35;
          leftCornerTop.position.z = 20;

          var rightCorner = new Physijs.BoxMesh(
              new THREE.BoxBufferGeometry(45, 40, 4),
              ground_material,
              0 // mass
          );
          rightCorner.rotation.x = Math.PI / 2;
          rightCorner.rotation.y = Math.PI / 4;
          rightCorner.position.x = 35;
          rightCorner.position.y = -35;
          rightCorner.position.z = 20;

          var rightCornerTop = new Physijs.BoxMesh(
              new THREE.BoxBufferGeometry(45, 40, 4),
              ground_material,
              0 // mass
          );
          rightCornerTop.rotation.x = Math.PI / 2;
          rightCornerTop.rotation.y = Math.PI / 4;

          rightCornerTop.position.x = -35;
          rightCornerTop.position.y = 35;
          rightCornerTop.position.z = 20;
          
          var smasherBottom = new Physijs.BoxMesh(
              new THREE.BoxBufferGeometry(10, 10, 40),
              ground_material,
              0 // mass
          );

          smasherBottom.position.z = 20;
          smasherBottom.position.y = -46;

          var smasherTop = smasherBottom.clone();
          smasherTop.position.y = 46;

          var smasherLeft = smasherBottom.clone();
          smasherLeft.position.x = -46;
          smasherLeft.position.y = 0;

          var smasherRight = smasherLeft.clone();
          smasherLeft.position.x = 46;

          var FakeSmasherBottom = new THREE.Mesh(
              new THREE.BoxBufferGeometry(10, 0.5, 40, 32),
              smasher_material,
              0 // mass
          );

          FakeSmasherBottom.position.z = 20;
          FakeSmasherBottom.position.y = -40;
          FakeSmasherBottom.rotation.z = Math.PI / 2;

          var fakeSmasherTop = FakeSmasherBottom.clone();
          fakeSmasherTop.position.y = 40;

          var fakeSmasherLeft = FakeSmasherBottom.clone();
          fakeSmasherLeft.rotation.z = Math.PI;
          fakeSmasherLeft.position.x = 40;
          fakeSmasherLeft.position.y = 0;

          var fakeSmasherRight = FakeSmasherBottom.clone();
          fakeSmasherRight.rotation.z = Math.PI;
          fakeSmasherRight.position.x = -40;
          fakeSmasherRight.position.y = 0;

          var mainAxe = new Physijs.CylinderMesh(
              new THREE.CylinderGeometry(0.5, 0.5, 90, 32),
              smasher_material,
              0 // mass
          );

          mainAxe.position.z = -1;

          var addAxe = mainAxe.clone();
          addAxe.rotation.z = Math.PI / 2;

          var centerAxe = new Physijs.CylinderMesh(
              new THREE.CylinderGeometry(1, 1, 40, 32),
              smasher_material,
              0 // mass
          );
          centerAxe.rotation.x = Math.PI / 2;
          centerAxe.position.z = 20;

          mainAxe.add(addAxe);

          frontWall.add(ground);
          frontWall.add(backWall);
          frontWall.add(rightWall);
          frontWall.add(leftWall);
          frontWall.add(leftCorner);
          frontWall.add(rightCorner);
          frontWall.add(smasherBottom);
          frontWall.add(smasherLeft);
          frontWall.add(smasherRight);
          frontWall.add(mainAxe);
          frontWall.add(centerAxe);
          frontWall.add(FakeSmasherBottom);
          frontWall.add(fakeSmasherTop);
          frontWall.add(fakeSmasherLeft);
          frontWall.add(fakeSmasherRight);

          scene.add(frontWall);

          return frontWall;
      }

      // Конструктор шара. Принимает в качестве параметров исходное положение в пространстве и номер, каким этот щар должен быть
      function makeBall(x, y, z, imageNum) {
          // На самом деле шара - это кубы. Иначе нельзя наложить текстуру с 6 сторон
          var geometry = new THREE.BoxGeometry( 1, 1, 1, 12, 12, 12 );
          for ( var i in geometry.vertices ) {
              var vertex = geometry.vertices[ i ];
              vertex.normalize().multiplyScalar(4); // Здесь кубы чисто визуально становятся шарами
          }

          // Подгрузка нужной текстуры
          var image = document.createElement( 'img' );
          image.src = `assets/balls/${imageNum}.png`;

          var texture = new THREE.Texture( image );
          image.addEventListener( 'load', function ( event ) {
              texture.needsUpdate = true;
          } );
          
          // Создание материала
          var sideMaterial = Physijs.createMaterial(
              new THREE.MeshBasicMaterial({
                  color: 0xffffff,
                  map: texture,
              }),
              0.4,
              0.6, // Если сделать больше коэфициент упругости, шары могут вылетать за пределы барабана после падения. не рекомендую
          );
          
          var materialArray = [];
 
          for (let i = 0; i < 6; i++) {
              materialArray.push(sideMaterial);
          }
          
          // Создание шара
          var ball = new Physijs.SphereMesh(geometry, sideMaterial, 5);
          ball.position.x = x;
          ball.position.y = y;
          ball.position.z = z;
          ball.castShadow = false;

          return ball;
      }
      
      // Ниже находятся функции, в которых можно почти смело ковыряться и не бояться что-нибудь сломать
      // Создает объекты с тексутрами автомата
      function makeGlass() {
          // Передняя часть автомата со стеклом (барабан и трубки)
          // Находится в пространстве перед всеми остальными объектами
        var material = new THREE.MeshBasicMaterial({
            map: THREE.ImageUtils.loadTexture('assets/GlassNew.png'),
            transparent: true,
            opacity: 1,
            color: 0xFFFFFF
        });

        var glass = new Physijs.BoxMesh(
            new THREE.PlaneGeometry(100, 190, 1), // текстура растягивается под эти размеры.
            material,
            0 // mass
        );
        
        glass.position.z = 90; // также, размер можно регулировать, приближая и отдаляя объект от начала координат
        glass.position.y = 34;

        // все то же самое, но это тело (черная часть позади всех объектов)
        var bodyMaterial = new THREE.MeshBasicMaterial({
            map: THREE.ImageUtils.loadTexture('assets/BodyNew2.png'),
            transparent: true,
            opacity: 1,
            color: 0xFFFFFF
        });

        var body = new Physijs.BoxMesh(
            new THREE.PlaneGeometry(118, 250, 1),
            bodyMaterial,
            0 // mass
        );

        body.position.z = -5;
        body.position.y = 33;
        body.position.x = -2;
        
        scene.add(glass);
        scene.add(body);
    }
    
    // Функция обновляет время на табло сверху. Вызывается каждые 10 сек (интервал задается в initScene)
      function updateTime() {
          let dataContainer = document.body.querySelector('.date');
          let date = new Date();
          let day = date.getDate();
          let month = date.getMonth() + 1;
          let year = date.getFullYear();
          
          let hours = date.getHours();
          let minutes = date.getMinutes();

          var ampm = hours >= 12 ? 'PM' : 'AM';
          hours = hours % 12;
          hours = hours ? hours : 12; // the hour '0' should be '12'
          minutes = minutes < 10 ? '0'+minutes : minutes;
          
          
          if (day < 10) {
              day = `0${day}`;
          }

          if (month < 10) {
              month = `0${month}`;
          }

          dataContainer.innerHTML =`${day}-${month}-${year}   ${hours}:${minutes} ${ampm}`;
          
          return `${year}-${month}-${day}`;
      }
      
      // Функция делает запрос к апи, возвращает ответ
      async function getWinningBalls() {
          let clientID = 'star99';
          let apiPass = '0123456789';
          let date = updateTime();
          let validationHash = hex_md5(`${clientID}:${date}:${apiPass}`);
          
          let requestString = `http://smartcar.temp.domains/~lotto/api/request.php?client_id=${clientID}&date=${date}&validation=${validationHash}`;

          return await fetch(`https://cors-anywhere.herokuapp.com/${requestString}`).then(resp => resp.json());
      }
      
      // Объект с текстурой самой сцены.
      // Можно было бы бэкграунд установить глобально для всего канваса, но тогда, при приближении/отдаленни,
      // он бы никак не менялся.
      function makeSceneBg() {
          var material = new THREE.MeshBasicMaterial({
              map: THREE.ImageUtils.loadTexture('assets/Stage.png'),
              transparent: true,
              opacity: 1,
              color: 0xFFFFFF
          });

          var bg = new Physijs.BoxMesh(
              new THREE.PlaneGeometry(822, 458, 1),
              material,
              0 // mass
          );
          
          bg.position.z = -100;
          bg.position.y = 20;
          
          scene.add(bg);
      }

      // Вспомогательная функция. Устанавливает нужный раунд, если что-то пошло не так.
      // открыть консоль, ввести setRound(r), где r - номер нужного раунда.
      // боковые таблицы заполняются до нужного раунда, игру можно продолжить с нужного раунда, не играя все с нуля.
      function setRound(r) {
          round = 23 - r + 1;

          for (let i = 23; i > round; i--) {
              let winningBalls = winningBallsAllRounds[i].split('');

              let winStr = `${winningBalls[0]} ${winningBalls[1]} ${winningBalls[2]} ${winningBalls[3]}`;

              document.body.querySelectorAll(`.round-${i}`).forEach(item => {
                  item.innerHTML = winStr;
              });
          }
      }
    
  </script>
</head>

<body>
<button class="start_btn" style="position: absolute; top: 10px; left: 10px; z-index: 10">Start</button>

<button class="fullscreen_btn" style="position: absolute; top: 40px; left: 10px; z-index: 10">full</button>
<div class="container">
  <div id="viewport">
    <div class="date"></div>
    <div class="win winning-0"></div>
    <div class="win winning-1"></div>
    <div class="win winning-2"></div>
    <div class="win winning-3"></div>
  
    <table class="score">
      <tr>
        <td></td>
        <td class="round-1"></td>
      </tr>
      <tr>
        <td></td>
        <td class="round-2"></td>
      </tr>
      <tr>
        <td></td>
        <td class="round-3"></td>
      </tr>
      <tr class="separator">
    
      </tr>
      <tr>
        <td class="round-4"></td>
        <td class="round-5"></td>
      </tr>
      <tr>
        <td class="round-6"></td>
        <td class="round-7"></td>
      </tr>
      <tr>
        <td class="round-8"></td>
        <td class="round-9"></td>
      </tr>
      <tr>
        <td class="round-10"></td>
        <td class="round-11"></td>
      </tr>
      <tr>
        <td class="round-12"></td>
        <td class="round-13"></td>
      </tr>
      <tr class="separator-2">
    
      </tr>
      <tr>
        <td class="round-14"></td>
        <td class="round-15"></td>
      </tr>
      <tr>
        <td class="round-16"></td>
        <td class="round-17"></td>
      </tr>
      <tr>
        <td class="round-18"></td>
        <td class="round-19"></td>
      </tr>
      <tr>
        <td class="round-20"></td>
        <td class="round-21"></td>
      </tr>
      <tr>
        <td class="round-22"></td>
        <td class="round-23"></td>
      </tr>
    </table>
  
    <table class="score-2">
      <tr>
        <td></td>
        <td class="round-1"></td>
      </tr>
      <tr>
        <td></td>
        <td class="round-2"></td>
      </tr>
      <tr>
        <td></td>
        <td class="round-3"></td>
      </tr>
      <tr class="separator">
    
      </tr>
      <tr>
        <td class="round-4"></td>
        <td class="round-5"></td>
      </tr>
      <tr>
        <td class="round-6"></td>
        <td class="round-7"></td>
      </tr>
      <tr>
        <td class="round-8"></td>
        <td class="round-9"></td>
      </tr>
      <tr>
        <td class="round-10"></td>
        <td class="round-11"></td>
      </tr>
      <tr>
        <td class="round-12"></td>
        <td class="round-13"></td>
      </tr>
      <tr class="separator-2">
    
      </tr>
      <tr>
        <td class="round-14"></td>
        <td class="round-15"></td>
      </tr>
      <tr>
        <td class="round-16"></td>
        <td class="round-17"></td>
      </tr>
      <tr>
        <td class="round-18"></td>
        <td class="round-19"></td>
      </tr>
      <tr>
        <td class="round-20"></td>
        <td class="round-21"></td>
      </tr>
      <tr>
        <td class="round-22"></td>
        <td class="round-23"></td>
      </tr>
    </table>
    
  </div>
</div>

</body>

</html>
